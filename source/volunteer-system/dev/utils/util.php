<?php

require_once('utils/defuse-crypto.phar');
use Defuse\Crypto\Key;
use Defuse\Crypto\Crypto;

// To update the encryption key, generate a new random (ASCII) key string using the above 
// Defuse library by calling the PHP command Key::createNewRandomKey()->saveToAsciiSafeString() 
// from this file after loading the library above. The resultant string has to be copied to 
// replace the one in Key::loadFromAsciiSafeString() immediately below. This can be done via 
// var_dump() to browser screen (or more securely by saving to file on server, sftp/scp file 
// from server, delete file from server).
$TRANS_SECRET_KEY = Key::loadFromAsciiSafeString("def000004bc8e04b9e014709800f029429763e2542e7f02e7277404241fc225e36d2cbfb1b57472e7049231b430b46c8bb7d5fd6538165356b7bc9ffbb1d96bfbfb09bb9");
// This key can be changed as desired; does not need to be generated by the Defuse library.
$TRANS_SECRET_EMBEDDED_KEY = "-g'c8c}'k0<_&r4e83(49eb0=>31}o4k";
// This delimeter can also be changed as desired, but should be something that won't match any
// susbstring that may appear in either the embedded key or a transaction ID.
$COMPOSITE_TRANS_ID_DELIMITER = "::";

$STD_MSG_TITLE = "";
$STD_MSG = array();
$STD_ERROR_MSG = array();
$SKIP_SCROLL_TOP = false;

$RESPITE_MIN_AGE = 16;
$CHILDCARE_MIN_AGE = 12;

function isErrors() {
	global $STD_ERROR_MSG;
	return count($STD_ERROR_MSG) > 0;
}

function setMsgTitle($msgTitle) {
	global $STD_MSG_TITLE;
	$STD_MSG_TITLE = $msgTitle;
}

function getMsgTitle() {
	global $STD_MSG_TITLE;
	return $STD_MSG_TITLE;
}

function setMsg($msg, $skipScrollTop=false) {
	global $STD_MSG, $SKIP_SCROLL_TOP;
	$STD_MSG[] = $msg;
	$SKIP_SCROLL_TOP = $skipScrollTop;
}

function setMsgs($msgs, $skipScrollTop=false) {
	global $STD_MSG, $SKIP_SCROLL_TOP;
	$STD_MSG = $msgs;
	$SKIP_SCROLL_TOP = $skipScrollTop;
}

function getMsgs() {
	global $STD_MSG;
	return $STD_MSG;
}

function setErrorMsg($msg, $skipScrollTop=true) {
	global $STD_ERROR_MSG, $SKIP_SCROLL_TOP;
	$STD_ERROR_MSG[] = $msg;
	$SKIP_SCROLL_TOP = $skipScrollTop;
}

function setErrorMsgs($msgs, $skipScrollTop=true) {
	global $STD_ERROR_MSG, $SKIP_SCROLL_TOP;
	$STD_ERROR_MSG = $msgs;
	$SKIP_SCROLL_TOP = $skipScrollTop;
}

function getErrorMsgs() {
	global $STD_ERROR_MSG;
	return $STD_ERROR_MSG;
}

// forward all messages via the session
// reloaded from session in mainController.php
function forwardAllMsgs() {
	$_SESSION['msgTitle'] = getMsgTitle();
	$_SESSION['msgs'] = getMsgs();
	$_SESSION['emsgs'] = getErrorMsgs();
}

function setSkipScrollTop($skipScrollTop) {
	global $SKIP_SCROLL_TOP;
	$SKIP_SCROLL_TOP = $skipScrollTop;
}

function printPageMessagesAndTitle($title) {
	printStdMsg();
	printStdErrorMsg();
	printPageTitle($title);
}

function printPageTitle($title) {
	echo "<h1>$title</h1>";
}

function printStdMsg() {
	global $STD_MSG, $SKIP_SCROLL_TOP, $STD_MSG_TITLE;
	if( count($STD_MSG) > 0 ) {
		$text = implode("</div><div>", $STD_MSG);
		$text = "<div>".$text."</div>";
		?>
		<script type="text/javascript">
		<?php if($SKIP_SCROLL_TOP) { echo "parent.skipNextScrollTop();"; } ?>
		parent.popupMessage("<?php echo $text; ?>", "<?php echo $STD_MSG_TITLE; ?>");
		</script>
		<?php
	}
	else if($SKIP_SCROLL_TOP) {
		?>
		<script type="text/javascript">
		parent.skipNextScrollTop();
		</script>
		<?php
	}
	// If this flag was true, it will have been processed and written out by now.
	// Clear it so it doesn't get written out again if printStgErrorMsg() is called.
	$SKIP_SCROLL_TOP = false;
}

function printStdErrorMsg() {
	global $STD_ERROR_MSG, $SKIP_SCROLL_TOP;
	if( count($STD_ERROR_MSG) > 0 ) {
		$text = implode("</div><div>", $STD_ERROR_MSG);
		$text = "<div>".$text."</div>";
		?>
		<script type="text/javascript">
		<?php if($SKIP_SCROLL_TOP) { echo "parent.skipNextScrollTop();"; } ?>
		parent.popupError("<?php echo $text; ?>");
		</script>
		<?php
	}
	else if($SKIP_SCROLL_TOP) {
		?>
		<script type="text/javascript">
		parent.skipNextScrollTop();
		</script>
		<?php
	}
	// If this flag was true, it will have been processed and written out by now.
	// Clear it so it doesn't get written out again if printStgMsg() is called.
	$SKIP_SCROLL_TOP = false;
}

function getNextTransactionIdEncoded() {
	global $COMPOSITE_TRANS_ID_DELIMITER, $TRANS_SECRET_EMBEDDED_KEY, $TRANS_SECRET_KEY;
	return Crypto::encrypt(getNextTransactionId().$COMPOSITE_TRANS_ID_DELIMITER.$TRANS_SECRET_EMBEDDED_KEY, $TRANS_SECRET_KEY);
}

function validateTransactionIdEncoded($tranIdEncoded) {
	global $COMPOSITE_TRANS_ID_DELIMITER, $TRANS_SECRET_EMBEDDED_KEY, $TRANS_SECRET_KEY;
	try {
		$compositeId = Crypto::decrypt($tranIdEncoded, $TRANS_SECRET_KEY);
	}
	catch (\Defuse\Crypto\Exception\WrongKeyOrModifiedCiphertextException $ex) {
		// Ivalid encoded ID.
		// Did not decrypt properly (including integrity check against modification).
		return false;
	}
	
	// At this point, we've proven the ID is one we generated (though it may be an old one
	// or one someone swapped in from another transaction). Both of these scenarios are
	// okay to proceed, though. We just want to prevent accidental replays of transactions 
	// (e.g., via browser navigation), and we want to do that in a way that prevents a 
	// hacker from damaging future transactions by submitting as yet unused IDs such that 
	// they get marked as used (and then future transactions get incorreclty treated as 
	// replays). In other words, a user is free to interfere with their own transactions.
	// The code is designed to protect data integrity against those kinds of replays.
	// We just don't want one user messing up transactions for other users.
	//
	// Without the secret key, no one can generate an encoded key that will pass the 
	// decryption stage and get to this point. And no one can modify an existing encoded
	// ID either and get to this point. Both will be flagged by the Crypto library.
	//
	// Security of the secret key itself is not a big issue. It's stored as a PHP string,
	// same as the DB password. The DB password is much more sensitive and an attacker 
	// could do a lot more damage with that password, so keeping the transaction secret
	// key here in a PHP file is good enough.
	
	$transIdParts = explode($COMPOSITE_TRANS_ID_DELIMITER, $compositeId);
	
	// For a little extra security against someone making up an encoded ID or modifying
	// one, we've included an embedded secret key as part of the transaction ID. Presumably 
	// no way someone could produce/modify an encoded ID such that it passes decryption and
	// also contains the proper embedded secret key. Here we validate the composite ID
	// format and that the embedded secret key is included properly.
	if(!$transIdParts || count($transIdParts) != 2 || $transIdParts[1] != $TRANS_SECRET_EMBEDDED_KEY) {
		// Invalid composite ID
		return false;
	}
	
	$transId = $transIdParts[0];
	
	// Now make sure the actual transaction ID is the right format
	if( !preg_match("/^[1-9][0-9]*$/", $transId) ) {
		// Invalid transaction ID
		return false;
	}
	
	// The transaction ID has been proved to be the right format and produced by us.
	// Now we verify that it is not a replay of a past executed transaction.
	// This is really the whole point of the transaction IDs, just to eliminate accidental
	// replays. The other mumbo jumbo is simply to prevent this ID infrastructure from
	// getting misused to harm the system and other users overall.
	return validateTransactionId($transId);
}

function getEncodedGetsPostsString() {
	$getsPosts = array();
	// Start by grabbing all requests (gets, posts, and cookies).
	// Important that we work from the $_REQUEST array becasue
	// of how it's used elsewhere.
	foreach($_REQUEST as $key => $val) {
		$getsPosts[$key] = $val;
	}
	// Now eleiminate any cookies. Don't want those persisted in 
	// a URL (at the very least because PHP session ID is in there).
	foreach($_COOKIE as $key => $val) {
		unset($getsPosts[$key]);
	}
	return urlencode(serialize($getsPosts));
}

function restoreAnyGetsPosts() {
	if( isset($_REQUEST['preserveGetsPosts']) ) {
		$getsPosts_serialized = $_REQUEST['preserveGetsPosts'];
		unset($_REQUEST);
		// Restore gets and posts, if any. Important that we work with
		// the $_REQUEST array because of how it's used elsewhere.
		$getsPosts = unserialize($getsPosts_serialized);
		if($getsPosts) {
			foreach($getsPosts as $key => $val) {
				$_REQUEST[$key] = $val;
			}
		}
		// Now put the cookies back in the $_REQUEST array
		foreach($_COOKIE as $key => $val) {
			$_REQUEST[$key] = $val;
		}
	}
}

function isReqSet($requestName) {
	return ( isset($_REQUEST[$requestName]) && $_REQUEST[$requestName] != "" );
}

function isValidIdentifierChars($str) {
	$validChars = "0123456789";
	$validChars .= "qwertyuiopasdfghjklzxcvbnm";
	$validChars .= "QWERTYUIOPASDFGHJKLZXCVBNM_";
	for($i=0; $i<strlen($str); $i++) {
		$nextChar = substr($str, $i, 1);
		if(!strstr($validChars, $nextChar)) {
			return false;
		}
	}
	return true;
}

function isValidHour($possibleHour) {
	if(preg_match("/^[0-9]+$/", $possibleHour) !== 1) {
		return false;
	}
	if($possibleHour < 1 || $possibleHour > 12) {
		return false;
	}
	return true;
}

function isValidMinute($possibleMinute) {
	if(preg_match("/^[0-9]+$/", $possibleMinute) !== 1) {
		return false;
	}
	if($possibleMinute < 0 || $possibleMinute > 59) {
		return false;
	}
	return true;
}

function endTimeIsBeforeStartTime($startTime, $endTime) {
	if(strtotime($startTime) > strtotime($endTime)) {
		return true;
	}
	return false;
}

function isValidDate($month, $day, $year) {
	// format: $month=mm or m, $day=dd or d, $year=yyyy or yyy or yy or y
	$isInt = '/^\d+$/';
	if( preg_match($isInt, $month) && preg_match($isInt, $day) && preg_match($isInt, $year) && checkdate($month, $day, $year) && strlen($year) < 5 ) {
		return true;
	}
	return false;
}

function isValidBirthdate($month, $day, $year) {
	// format: $month=mm or m, $day=dd or d, $year=yyyy or yyy or yy or y
	if( isValidDate($month, $day, $year) &&
		$year > (date('Y')-125) &&
		$year < date('Y') ) {
		return true;
	}
	return false;
}

function isPastDate($month, $day, $year) {
	// format: $month=mm or m, $day=dd or d, $year=yyyy
	$month = (strlen($month) == 2) ? $month : "0".$month;
	$day = (strlen($day) == 2) ? $day : "0".$day;
	$givenDate = $year."-".$month."-".$day;
	$currDate = getMySqlDate(time());
	return ($givenDate < $currDate);
}

function getMySqlDate($timestamp) {
	// returns the date corresponding to the given unix timestamp in the MySQL DATE format (yyyy-mm-dd)
	$dateAry = getdate($timestamp);
	$date = $dateAry['year'];
	$date .= "-";
	$date .= (strlen($dateAry['mon']) == 2) ? $dateAry['mon'] : "0".$dateAry['mon'];
	$date .= "-";
	$date .= (strlen($dateAry['mday']) == 2) ? $dateAry['mday'] : "0".$dateAry['mday'];
	return $date;
}

function formatDateAsNumeric_monthDayYear($date, $includeTime = false) {
	//$date: expected format yyyy-mm-dd hh:mm:ss
	$dateAry = getdate(strtotime($date));
	$time = ($includeTime) ? " ".formatTime($date) : "";
	return $dateAry['mon']."/".$dateAry['mday']."/".$dateAry['year'].$time;
}

function formatDateAsText_monthDayYear($date, $includeTime = false) {
	//$date: expected format yyyy-mm-dd hh:mm:ss
	$dateAry = getdate(strtotime($date));
	$time = ($includeTime) ? " ".formatTime($date) : "";
	return substr($dateAry['month'], 0, 3)." ".$dateAry['mday'].", ".$dateAry['year'].$time;
}

function formatDateAsText_weekdayMonthDay($date) {
	//$date: expected format yyyy-mm-dd
	$dateAry = getdate(strtotime($date));
	if($dateAry['mday'] == 1 || $dateAry['mday']-20 == 1 || $dateAry['mday']-30 == 1) {
		$dayAdtl = "st";
	}
	else if($dateAry['mday'] == 2 || $dateAry['mday']-20 == 2) {
		$dayAdtl = "nd";
	}
	else if($dateAry['mday'] == 3 || $dateAry['mday']-20 == 3) {
		$dayAdtl = "rd";
	}
	else {
		$dayAdtl = "th";
	}
	return $dateAry['weekday'].", ".$dateAry['month']." ".$dateAry['mday'].$dayAdtl;
}

function formatTime($date) {
	//$date: expected format yyyy-mm-dd hh:mm:ss
	$dateAry = getdate(strtotime($date));
	$minutes = ($dateAry['minutes'] < 10) ? "0".$dateAry['minutes'] : $dateAry['minutes'];
	if($dateAry['hours'] < 1) {
		$hours = 12;
		$addtl = "AM";
	}
	else if($dateAry['hours'] < 12) {
		$hours = $dateAry['hours'];
		$addtl = "AM";
	}
	else if($dateAry['hours'] < 13) {
		$hours = $dateAry['hours'];
		$addtl = "PM";
	}
	else {
		$hours = $dateAry['hours']-12;
		$addtl = "PM";
	}
	return $hours.":".$minutes." ".$addtl;
}

function formatTimeForSQL($timeAmPm, $hour, $minutes) {
	$formattedTime = strftime("%H:%M", strtotime($hour.":".$minutes." ".$timeAmPm)).":00";
	return $formattedTime;
}

function isValidZipCode($zip) {
	if(preg_match("/^[0-9]{5}$/", $zip) === 1) {
		return true;
	}
	return false;
}

function isValidPhoneNumber($areaCode, $part1, $part2) {
	if( preg_match("/^[0-9]{3}$/", $areaCode) === 1 &&
		preg_match("/^[0-9]{3}$/", $part1) === 1 &&
		preg_match("/^[0-9]{4}$/", $part2) === 1) {	
		return true;
	}
	return false;
}

function isValidEmailAddress($email) {
	return preg_match("/^[^\s@]+@[^\s@]+\.[^\s@]+$/", $email);
}

function truncate($str, $maxlength) {
	return (strlen($str) > $maxlength) ? substr($str, 0, $maxlength) : $str;
}

function generateRandomPassword($length = 8) {
	$password = "";
	$possibleChars = "0123456789";
	$possibleChars .= "qwertyuiopasdfghjklzxcvbnm";
	$possibleChars .= "QWERTYUIOPASDFGHJKLZXCVBNM";

	// add random characters to $password until $length is reached
	for($i=0; $i<$length; $i++) { 
		// pick a random character from the possible ones
		$password .= substr($possibleChars, mt_rand(0, strlen($possibleChars)-1), 1);
	}

	return $password;
}

function getAnyAgeRestrictionErrorMsg($birthdate, $eventType) {
	global $RESPITE_MIN_AGE, $CHILDCARE_MIN_AGE;
	if($eventType == "Respite" && calculateAgeFromBirthdate($birthdate) < $RESPITE_MIN_AGE) {
		return "You must be at least ".$RESPITE_MIN_AGE." years old to sign up.";
	}
	else if($eventType == "Childcare" && calculateAgeFromBirthdate($birthdate) < $CHILDCARE_MIN_AGE) {
		return "You must be at least ".$CHILDCARE_MIN_AGE." years old to sign up.";
	}
	return "";
}

function calculateAgeFromBirthdate($birthdate) {
	//$birthdate: expected format yyyy-mm-dd
	list($birthyear, $birthmonth, $birthday) = explode("-", $birthdate);
	
	$yearDiff = date("Y") - $birthyear;
	$curr = date("m").date("d");
	
	// If the birthday has not occured this year
	if($birthmonth.$birthday > $curr) {
		$yearDiff--;
	}
	
	return $yearDiff;
}

function stripGPCSlashes() {
	if(get_magic_quotes_gpc()) {
		foreach($_REQUEST as $key => $val) {
			$_REQUEST[$key] = stripslashes($val);
		}
		foreach($_GET as $key => $val) {
			$_GET[$key] = stripslashes($val);
		}
		foreach($_POST as $key => $val) {
			$_POST[$key] = stripslashes($val);
		}
		foreach($_COOKIE as $key => $val) {
			$_COOKIE[$key] = stripslashes($val);
		}
	}
}

function getVolunteersAdminEmailLink($style="") {
	$volunteersAdminInfo = mysqli_fetch_assoc( getVolunteersAdminInfo() );
	if( !isset($volunteersAdminInfo) || !$volunteersAdminInfo || !isset($volunteersAdminInfo['email']) || !$volunteersAdminInfo['email'] || $volunteersAdminInfo['email'] == "" ) {
		return "";
	}
	return "<a target='_blank' href='mailto:".$volunteersAdminInfo['email']."' style='".$style."'>".$volunteersAdminInfo['email']."</a>";
}

function getVolunteersAdminPhone() {
	$volunteersAdminInfo = mysqli_fetch_assoc( getVolunteersAdminInfo() );
	return $volunteersAdminInfo['phone'];
}

function getLocationAddress($location, $delimiter="\n") {
	if($location == "Orem") {
		$addressParts = array("Kids On The Move", "475 West 260 North", "Orem, UT 84057");
	}
	else if($location == "Salem") {
		$addressParts = array("Kids On The Move", "Located within Kids Who Count", "345 North State Road 198", "Salem, UT 84653");
	}
	else if($location == "Springville") {
		$addressParts = array("Kids On The Move", "Located within TURN Community Services (entrance on Main St. side of the building)", "451 S. Main St.", "Suites 3 & 4", "Springville, UT 84663");
	}
	else if($location == "Lehi") {
		$addressParts = array("Kids On The Move (satellite location)", "Trailer on grounds of Snow Springs Elementary School", "850 South 1700 West", "Lehi, UT 84043");	
	}
	else if($location == "St. George") {
		$addressParts = array("Kids On The Move", "398 E. Tabernacle", "St. George, UT 84770");
	}
	else {
		throw new Exception("error, unrecognized location in getLocationAddress()");
	}
	
	return implode($delimiter, $addressParts);
}

function getLocationDirectionsURL($location) {
	if($location == "Orem") {
		$directionsURL = getURLForParentSite("?page_id=17441");
	}
	else if($location == "Salem") {
		$directionsURL = getURLForParentSite("?page_id=-1"); // no longer used; no directions page exists
	}
	else if($location == "Springville") {
		$directionsURL = getURLForParentSite("?page_id=17446");
	}
	else if($location == "Lehi") {
		$directionsURL = getURLForParentSite("?page_id=17444");
	}
	else if($location == "St. George") {
		$directionsURL = getURLForParentSite("?page_id=17448");
	}
	else {
		throw new Exception("error, unrecognized location in getLocationDirectionsURL()");
	}
	
	return $directionsURL;
}

function getLocationDirectionsAnchorLink($location, $innerHtml=null) {
	if(is_null($innerHtml)) {
		$innerHtml = htmlentities($location);
	}
	return "<a href='".getLocationDirectionsURL($location)."' target='_blank'>".$innerHtml."</a>";
}

function getURLForParentSite($getters) {
	return "https://".$_SERVER["SERVER_NAME"]."/".$getters;
}

function processMarkupForHtmlDisplay($text) {
	return _processMarkup($text, true);
}

function processMarkupForTextDisplay($text) {
	return _processMarkup($text, false);
}

function _processMarkup($text, $forHtml) {
	$boldWrapper = array("<span style='font-weight:bold;'>", "</span>");
	$italicWrapper = array("<span style='font-style:italic;'>", "</span>");
	$underlineWrapper = array("<span style='text-decoration:underline;'>", "</span>");
	$urlWrapper = array("<a href='", "' target='_blank'>", "</a>");
	// if html, escape html chars, preserve whitespace
	if($forHtml) {
		$text = htmlentities($text);
		$text = "<span style='white-space:pre-wrap;'>".$text."</span>";
	}
	// strip carriage returns, if any
	$text = str_replace("\r", "", $text);
	// explode on newlines
	$lines = explode("\n", $text);
	// iterate over lines
	for($i=0; $i<count($lines); $i++) {
		$line = $lines[$i];
		// extract urls to array
		preg_match_all("/\[\[(.*?)\]\]/", $line, $matches);
		$urls = $matches[1];
		// if html, apply wrapper to urls, otherwise urls are plain text
		if($forHtml) {
			for($j=0; $j<count($urls); $j++) {
				$urls[$j] = $urlWrapper[0].$urls[$j].$urlWrapper[1].$urls[$j].$urlWrapper[2];
			}
		}
		// replace all '[[url]]' with '[[]]' as marker
		$line = preg_replace("/\[\[.*?\]\]/", "[[]]", $line);
		// if html, apply wrappers for bold, italic, underline; otherwise eliminate markup
		if($forHtml) {
			// bold
			$line = preg_replace("/\*(.*?)\*/", $boldWrapper[0]."$1".$boldWrapper[1], $line);
			// italic
			$line = preg_replace("/~(.*?)~/", $italicWrapper[0]."$1".$italicWrapper[1], $line);
			// underline
			$line = preg_replace("/_(.*?)_/", $underlineWrapper[0]."$1".$underlineWrapper[1], $line);
		}
		else {
			// bold
			$line = preg_replace("/\*(.*?)\*/", "$1", $line);
			// italic
			$line = preg_replace("/~(.*?)~/", "$1", $line);
			// underline
			$line = preg_replace("/_(.*?)_/", "$1", $line);
		}
		// explode line on url marker
		$segments = explode("[[]]", $line);
		// paste line back together with urls in place of markers
		$line = "";
		for($j=0; $j<count($segments)-1; $j++) {
			$line .= $segments[$j].$urls[$j];
		}
		$line .= $segments[count($segments)-1];
		$lines[$i] = $line;
	}
	// paste lines back together with appropriate newline deliminter for given output type
	$newline = "\n";
	if($forHtml) {
		$newline = "<br/>";
	}
	return implode($newline, $lines);
}

// Helper function for mergeDates() below.
function firstDateIsBeforeSecond($date1, $date2, $datesAreCurrent, $primarySortBy) {
	// Sort order (with the following caveat described below):
	// 		Current Events: `date` asc, `type` asc, `location` asc, `signupDate` asc
	// 		Past Events: `date` desc, `type` asc, `location` asc, `signupDate` desc
	// 
	// Sort order fillows that shown above except that if $primarySortBy matches one
	// of the four fields, that field is promoted to the first position for sorting.
	// All other fields subsequently follow in their order shown above.
	// 
	// 'date' format: "yyyy-mm-dd"
	// 'signupDate' format: "yyyy-mm-dd hh:mm:ss"
	// Both dates are comparable as strings for ordering.
	if($datesAreCurrent) {
		if($primarySortBy == "type") { // sort order: type, date, location, signupDate
			if( $date1['type'] !== $date2['type'] ) {
				return $date1['type'] < $date2['type'];
			}
			else if( $date1['date'] !== $date2['date'] ) {
				return $date1['date'] < $date2['date'];
			}
			else if( $date1['location'] !== $date2['location'] ) {
				return $date1['location'] < $date2['location'];
			}
			else {
				// Practically speaking, these should never be equal for the same user
				return $date1['signupDate'] < $date2['signupDate'];
			}
		}
		else if($primarySortBy == "location") { // sort order: location, date, type, signupDate
			if( $date1['location'] !== $date2['location'] ) {
				return $date1['location'] < $date2['location'];
			}
			else if( $date1['date'] !== $date2['date'] ) {
				return $date1['date'] < $date2['date'];
			}
			else if( $date1['type'] !== $date2['type'] ) {
				return $date1['type'] < $date2['type'];
			}
			else {
				// Practically speaking, these should never be equal for the same user
				return $date1['signupDate'] < $date2['signupDate'];
			}
		}
		else if($primarySortBy == "signupDate") { // sort order: signupDate, date, type, location
			if( $date1['signupDate'] != $date2['signupDate'] ) {
				// Practically speaking, these should never be equal for the same user
				return $date1['signupDate'] < $date2['signupDate'];
			}
			else if( $date1['date'] !== $date2['date'] ) {
				return $date1['date'] < $date2['date'];
			}
			else if( $date1['type'] !== $date2['type'] ) {
				return $date1['type'] < $date2['type'];
			}
			else {
				return $date1['location'] < $date2['location'];
			}
		}
		else { // default sort order: date, type, location, signupDate
			if( $date1['date'] !== $date2['date'] ) {
				return $date1['date'] < $date2['date'];
			}
			else if( $date1['type'] !== $date2['type'] ) {
				return $date1['type'] < $date2['type'];
			}
			else if( $date1['location'] !== $date2['location'] ) {
				return $date1['location'] < $date2['location'];
			}
			else {
				// Practically speaking, these should never be equal for the same user
				return $date1['signupDate'] < $date2['signupDate'];
			}
		}
	}
	else {
		if($primarySortBy == "type") { // sort order: type, date, location, signupDate
			if( $date1['type'] !== $date2['type'] ) {
				return $date1['type'] < $date2['type'];
			}
			else if( $date1['date'] !== $date2['date'] ) {
				return $date1['date'] > $date2['date'];
			}
			else if( $date1['location'] !== $date2['location'] ) {
				return $date1['location'] < $date2['location'];
			}
			else {
				// Practically speaking, these should never be equal for the same user
				return $date1['signupDate'] > $date2['signupDate'];
			}
		}
		else if($primarySortBy == "location") { // sort order: location, date, type, signupDate
			if( $date1['location'] !== $date2['location'] ) {
				return $date1['location'] < $date2['location'];
			}
			else if( $date1['date'] !== $date2['date'] ) {
				return $date1['date'] > $date2['date'];
			}
			else if( $date1['type'] !== $date2['type'] ) {
				return $date1['type'] < $date2['type'];
			}
			else {
				// Practically speaking, these should never be equal for the same user
				return $date1['signupDate'] > $date2['signupDate'];
			}
		}
		else if($primarySortBy == "signupDate") { // sort order: signupDate, date, type, location
			if( $date1['signupDate'] != $date2['signupDate'] ) {
				// Practically speaking, these should never be equal for the same user
				return $date1['signupDate'] > $date2['signupDate'];
			}
			else if( $date1['date'] !== $date2['date'] ) {
				return $date1['date'] > $date2['date'];
			}
			else if( $date1['type'] !== $date2['type'] ) {
				return $date1['type'] < $date2['type'];
			}
			else {
				return $date1['location'] < $date2['location'];
			}
		}
		else { // default sort order: date, type, location, signupDate
			if( $date1['date'] !== $date2['date'] ) {
				return $date1['date'] > $date2['date'];
			}
			else if( $date1['type'] !== $date2['type'] ) {
				return $date1['type'] < $date2['type'];
			}
			else if( $date1['location'] !== $date2['location'] ) {
				return $date1['location'] < $date2['location'];
			}
			else {
				// Practically speaking, these should never be equal for the same user
				return $date1['signupDate'] > $date2['signupDate'];
			}
		}
	}
}

// The two date arrays are kept in their orders given, but are zipped together
// into a single array based on the following sort order (unless $sortby is 
// specified):
// 		Current Events: `date` asc, `type` asc, `location` asc, `signupDate` asc
// 		Past Events: `date` desc, `type` asc, `location` asc, `signupDate` desc
// 
// If $sortby is specified, and matches either `type`, `location`, or `signupDate`
// then that field is used as the primary sort before `date`. All other fields are 
// subsequently applied for sorting in the order shown above.
// 
// All dates in both arrays should be of the same timeframe (i.e., either current
// or past, as indicated by the third parameter).
// 
// The first elements of each array are compared, sort order is used to select the
// one that should be first. A reference to the selected element is copied into
// the destination array, and the index for the selected source array is advanced.
// The non-selected element remains to be compared in the next round against the
// second element of the prior selected source array. Comparisons continue until
// one or both of the two arrays run out of elements. At that point, if one of
// the two arrays still has elements, those elements are copied over in their 
// order given to the destination array.
//
// The algorithm expects dates to be formatted as they are received from the 
// database (i.e., mysql date and timestamp formats, "yyyy-mm-dd" and 
// "yyyy-mm-dd hh:mm:ss", respectively).
// 
// The algorithm also expects each item in the date arrays to be a hash array
// with keys (at minimum) matching and including all those identified above with 
// respect to the sort ordering. ***NOTE that this means special events should 
// include the `type` field (e.g., set to "Special Event"), even though the 
// database does not return a `type` field for special events.
// 
function mergeDates($dates1, $dates2, $datesAreCurrent, $sortby="date") {
	$datesAll = array();
	$index1 = 0;
	$index2 = 0;
	while( count($dates1) > $index1 || count($dates2) > $index2 ) {
		if( count($dates1) > $index1 && count($dates2) > $index2 ) {
			$date1 = $dates1[$index1];
			$date2 = $dates2[$index2];
			if( firstDateIsBeforeSecond($date1, $date2, $datesAreCurrent, $sortby) ) {
				$datesAll[] = $date1;
				$index1++;
			}
			else {
				$datesAll[] = $date2;
				$index2++;
			}
		}
		else if( count($dates1) > $index1 ) {
			$datesAll[] = $dates1[$index1];
			$index1++;
		}
		else {
			$datesAll[] = $dates2[$index2];
			$index2++;
		}
	}
	return $datesAll;
}

?>